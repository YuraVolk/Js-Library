"use strict";(self.webpackChunkjs_react_components_library=self.webpackChunkjs_react_components_library||[]).push([[9828],{9828:(e,t,n)=>{n.r(t),n.d(t,{default:()=>E});var r=n(6540),i=n(5072),l=n.n(i),a=n(7825),o=n.n(a),s=n(7659),c=n.n(s),u=n(5056),p=n.n(u),d=n(540),m=n.n(d),g=n(1113),f=n.n(g),h=n(8113),b={};b.styleTagTransform=f(),b.setAttributes=p(),b.insert=c().bind(null,"head"),b.domAPI=o(),b.insertStyleElement=m(),l()(h.A,b);const y=h.A&&h.A.locals?h.A.locals:void 0;var v=n(7687);function x(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,r=new Array(t);n<t;n++)r[n]=e[n];return r}var w=n(5749),T=["repetitions","interval","typingSpeed"];var S=e=>{var t=e.repetitions,n=void 0===t?1:t,i=e.interval,l=void 0===i?2500:i,a=e.typingSpeed,o=void 0===a?75:a,s=function(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},l=Object.keys(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}(e,T),c=(0,r.useCallback)((e=>{for(var t=e.context,n=e.fromText,r=e.toText,i=(0,w.createRebuildingTextSteps)(n,r),a=function(e){setTimeout((()=>{t.setCurrentTextValue(i[e].filter((e=>Boolean(e))).map((e=>({letter:e,classes:[]})))),e===i.length-1&&setTimeout((()=>{t.onInterval()}),l)}),o*e)},s=0;s<i.length;s++)a(s)}),[l,o]),u=function(e){var t,n,i=(0,r.useRef)(),l=(0,r.useRef)(),a=(t=(0,r.useState)((()=>e.strings[0].split("").map((e=>({letter:e,classes:[]}))))),n=2,function(e){if(Array.isArray(e))return e}(t)||function(e,t){var n=null==e?null:"undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null!=n){var r,i,l,a,o=[],s=!0,c=!1;try{if(l=(n=n.call(e)).next,0===t){if(Object(n)!==n)return;s=!1}else for(;!(s=(r=l.call(n)).done)&&(o.push(r.value),o.length!==t);s=!0);}catch(e){c=!0,i=e}finally{try{if(!s&&null!=n.return&&(a=n.return(),Object(a)!==a))return}finally{if(c)throw i}}return o}}(t,n)||function(e,t){if(e){if("string"==typeof e)return x(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);return"Object"===n&&e.constructor&&(n=e.constructor.name),"Map"===n||"Set"===n?Array.from(e):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?x(e,t):void 0}}(t,n)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()),o=a[0],s=a[1],c=(0,r.useMemo)((()=>{var t={interval:i,currentTextValue:o,setCurrentTextValue:s,onInterval:r},n=n=>{e.triggerTextAnimation({context:t,fromText:n[0],toText:n[1]})};function r(){var t;null!==(t=l.current)&&void 0!==t||(l.current=(0,v.nextStringsGenerator)(e.strings[0],e));var r=l.current.next(),a=r.done,o=r.value;a?(window.clearTimeout(i.current),i.current=void 0):n(o)}return{context:t,onInterval:r}}),[o,e]),u=c.context,p=c.onInterval;return(0,r.useEffect)((()=>()=>{var t;null===(t=l.current)||void 0===t||t.return(["",""]),l.current=(0,v.nextStringsGenerator)(e.strings[0],e),window.clearTimeout(i.current)}),[e.strings]),(0,r.useEffect)((()=>{var t;null===(t=e.splitText)||void 0===t||t.call(e,{context:u}),i.current=window.setTimeout((()=>{p()}),e.interval)}),[]),o}({strings:s.strings,repetitions:n,interval:l,typingSpeed:o,triggerTextAnimation:c});return r.createElement("pre",{className:s.className},u.map(((e,t)=>r.createElement("span",{className:e.classes.join(""),key:"".concat(e.letter,"-").concat(String(t))},e.letter))))};const E=()=>r.createElement("main",{className:"main"},r.createElement("h1",{className:"heading"},"Rebuilding Text"),r.createElement("p",null,"The rebuilding text component is a custom component that allows you to display text in a rebuilding manner. It takes an array of strings and displays them one by one, with each string being rebuilt and revealed gradually. This component adds an interesting visual effect to your web application or website. You could think of the core logic of this effect to bridge the gap in difference between the two words through swapping the letters, bridging the middle gap between two words. Here are the component props:"),r.createElement("ul",null,r.createElement("li",null,"strings: the main configuration prop that is passed as an array of strings."),r.createElement("li",null,"repetitions: the amount of repetitions the rebuilding text component will get rebuilt. Defaults to one repetition."),r.createElement("li",null,"interval: the delay between text animations, defaults to 2500 milliseconds."),r.createElement("li",null,"typingSpeed: the rebuilding speed of an individual character. Defaults to 75 milliseconds.")),r.createElement("p",null,"Here is an example of this component:"),r.createElement(S,{strings:["Test text","The new resulting text","Small"],repetitions:1/0,className:y["rebuilding-text"]}),r.createElement("p",null,"Here is another example of the component with two same length words:"),r.createElement(S,{strings:["Hello","World"],repetitions:1/0,className:y["rebuilding-text"]}),r.createElement("p",null,'In this example, the rebuilding text component is used to display the strings "Hello" and "World" in a swapped manner. The strings will be repeated twice with an interval of 3 seconds between repetitions. The typing speed is set to 45 characters per second. The pre element is used as the target element for displaying the rebuilt text. Here you can closely observe how the algorithm works:'),r.createElement(S,{strings:["Test text","The new resulting text","Small"],repetitions:1/0,typingSpeed:300,className:y["rebuilding-text"]}))},8113:(e,t,n)=>{n.d(t,{A:()=>o});var r=n(1601),i=n.n(r),l=n(6314),a=n.n(l)()(i());a.push([e.id,".yz4S0aG0xeXz08jtz9xX {\n\tfont-size: 24px;\n\tline-height: 54px;\n\twhite-space: nowrap;\n}\n",""]),a.locals={"rebuilding-text":"yz4S0aG0xeXz08jtz9xX"};const o=a}}]);